Все файлы с наработками лежат в src. В submodules лежат пропатченные репы проектов, которые мы используем для реализации алгоритма RMA.
 Сделан интерфейс, который решает задачу взаимодействия программы с реальным роботом или симмуляцией mujo. Т.е. предполагается, что без изменения программы управления роботом мы можем отлаживаться как в симмуляции так и на реальном роботе. Интерфейс представляет собой абстрактный класс RobotProxy с абстрактными методами:
* start() - запуск симмуляции или подключение к роботу
* send_impl(cmd: lowCmd) - посылает команду роботу. Команда это объект, реализующий класс lowCmd из freedogs-sdk
* get_states_impl() - получить состояний от робота. Робот присылает свое состояние каждую миллисекунду. Если читать состояния медленее, то они могут накапливаться. Поэтому метод может возратить None если робот не прислал состояние или вернуть несколько состояний. Состояние - это пара (временная метка получения состояния, lowState).lowState- это тоже класс из freedogs-sdk
Так же интерфейс берет на себя:
1) отправку состояний и команд в мониторинг plotjuggler.
2) оповещение, если мы пытаемся отправить углы моторов, которые не укладываются в диапозон возможных углов
3) (планы) логгирование состояний и команд
4) (планы) оценка финальных моментов, которые будут применены к моторам

Есть набор программ, которые работают через интерфейс:
* standup.py - поднять робота из положения лежа. Работает как в симмуляции, так и на реальном роботе. Выбор можно делается флагом real в коде программы
* policy.py - применить обученную RMA политику на роботе. Пока находится в состоянии отладки
* stand.py - в симуляции задать позицию и заставить робота удерживать ее.
* test.py и test_real.py - подключиться к симмуляции или роботу и просто считывать состояния

Симмуляция реализована в simulation.py. Когда программа запускается в режиме симуляции, то она работает в 3 потока:
1) Основной поток программы
2) Поток симмуляции - в котором с заданной частотой происходит получение команды, шаг симмуляции и отправка состояния
3) Поток визуализации - он создается где-то внутри сишного кода mujoco

Есть настройки симмуляции в файле config.py

В модуле command.py есть удобный класс Command, который по массивам позиций, скоростей, моментов создает команду для freedogs. И еще функции, тоже облегчающие создание команд

В utils.py есть q_vec - которая из состояния freedogs получает вектор позиций моторов
